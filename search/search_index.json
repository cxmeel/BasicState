{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BasicState \u00b6 BasicState is a really, really simple key-value based state management solution. It makes use of BindableEvents to allow your projects to watch for changes in state, and provides a simple API for communication with your state objects. Think Rodux , but much more simple. Getting Started \u00b6 It's easy to get started using BasicState. There are a few methods to add BasicState to your project: Info It's recommended that you place the BasicState module in a place like ReplicatedStorage , as it can be used on both the client and server; however, this is not mandatory. Method 1: Wally \u00b6 Add BasicState to your wally.toml and run wally install [package] name = \"user/repo\" description = \"My awesome Roblox project\" version = \"1.0.0\" license = \"MIT\" authors = [\"You (https://github.com/you)\"] registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] BasicState = \"csqrl/BasicState@^0.2.6\" $ wally install Method 2: Rojo \u00b6 You can use git submodules to clone this repo into your project's packages directory: $ git submodule add https://github.com/csqrl/BasicState packages/BasicState Once added, simply sync into Studio using the Rojo plugin. 0.5.x \u00b6 Download/clone this repo on to your device, and copy the /src directory into your packages directory. Method 3: Roblox-TS (unofficial) \u00b6 While this package doesn't officially support TypeScript, bindings are available under the @rbxts/basicstate package, which can be installed using npm or yarn. $ npm i @rbxts/basicstate $ yarn add @rbxts/basicstate $ pnpm add @rbxts/basicstate TypeScript bindings are provided by @tech0tron . Please file any issues for the npm package over on their repo . Method 4: Manual Installation \u00b6 Grab a copy from the Roblox Library (Toolbox) , or download the latest .rbxm/.rbxmx file from the releases page and drop it into Studio. Method 5: Git Submodules \u00b6 Follow the instructions in the following Gist to import a GitHub repo as a submodule. This allows you to link modules into your project, and sync updates when they become available: https://gist.github.com/gitaarik/8735255#adding-a-submodule","title":"Home"},{"location":"#basicstate","text":"BasicState is a really, really simple key-value based state management solution. It makes use of BindableEvents to allow your projects to watch for changes in state, and provides a simple API for communication with your state objects. Think Rodux , but much more simple.","title":"BasicState"},{"location":"#getting-started","text":"It's easy to get started using BasicState. There are a few methods to add BasicState to your project: Info It's recommended that you place the BasicState module in a place like ReplicatedStorage , as it can be used on both the client and server; however, this is not mandatory.","title":"Getting Started"},{"location":"#method-1-wally","text":"Add BasicState to your wally.toml and run wally install [package] name = \"user/repo\" description = \"My awesome Roblox project\" version = \"1.0.0\" license = \"MIT\" authors = [\"You (https://github.com/you)\"] registry = \"https://github.com/UpliftGames/wally-index\" realm = \"shared\" [dependencies] BasicState = \"csqrl/BasicState@^0.2.6\" $ wally install","title":"Method 1: Wally"},{"location":"#method-2-rojo","text":"You can use git submodules to clone this repo into your project's packages directory: $ git submodule add https://github.com/csqrl/BasicState packages/BasicState Once added, simply sync into Studio using the Rojo plugin.","title":"Method 2: Rojo"},{"location":"#05x","text":"Download/clone this repo on to your device, and copy the /src directory into your packages directory.","title":"0.5.x"},{"location":"#method-3-roblox-ts-unofficial","text":"While this package doesn't officially support TypeScript, bindings are available under the @rbxts/basicstate package, which can be installed using npm or yarn. $ npm i @rbxts/basicstate $ yarn add @rbxts/basicstate $ pnpm add @rbxts/basicstate TypeScript bindings are provided by @tech0tron . Please file any issues for the npm package over on their repo .","title":"Method 3: Roblox-TS (unofficial)"},{"location":"#method-4-manual-installation","text":"Grab a copy from the Roblox Library (Toolbox) , or download the latest .rbxm/.rbxmx file from the releases page and drop it into Studio.","title":"Method 4: Manual Installation"},{"location":"#method-5-git-submodules","text":"Follow the instructions in the following Gist to import a GitHub repo as a submodule. This allows you to link modules into your project, and sync updates when they become available: https://gist.github.com/gitaarik/8735255#adding-a-submodule","title":"Method 5: Git Submodules"},{"location":"docs/","text":"BasicState.new() \u00b6 Creates a new state object. Accepts an optional InitialState parameter, for defining the state before it is returned. Syntax \u00b6 BasicState.new([ InitialState: Dictionary<any, any> = {} ]): State State:Set() \u00b6 Sets the value of a given key in the state, and then fires off any Changed signals. You should always use this when you need to change the state. Use :RawSet() to change values without invoking change events. Syntax \u00b6 State:Set(Key: any, Value: any): void State:SetState() \u00b6 Set multiple values in the state. Changed signals will be fired for each modified key. Syntax \u00b6 State:SetState(StateTable: Dictionary<any, any>): void State:SetState(Callback: (State: Dictionary<any, any>) -> Dictionary<any, any>): void Example \u00b6 local State = BasicState . new ({ Location = \"Mountain\" , Greetings = { Place = \"Welcome to the Mountain!\" , Roblox = \"Hey Roblox!\" , Me = \"Hi csqrl!\" } }) State : SetState ({ Location = \"City\" , Greetings = { Place = \"Welcome to the City!\" } }) --[[ The new state object will look like this: { Location = \"City\", Greetings = { Place = \"Welcome to the City!\", Roblox = \"Hey Roblox!\", Me = \"Hi csqrl!\" } } --]] State:Reset() \u00b6 Resets state back to its initial keys/values. Syntax \u00b6 State:Reset(): void State:Delete() \u00b6 Deletes a key from the store by setting its value to State.None (internally converted to nil ). Syntax \u00b6 State:Delete(Key: any): void Example \u00b6 local State = BasicState . new ({ Hello = \"World\" }) State : Delete ( \"Hello\" ) print ( State : Get ( \"Hello\" )) --> nil State:Toggle() \u00b6 Toggles a stored Boolean value between true and false . Will throw an error if the stored value is not a Boolean. Syntax \u00b6 State:Toggle(Key: any): void Example \u00b6 local State = BasicState . new ({ MenuOpen = false }) State : Toggle ( \"MenuOpen\" ) --> true State : Toggle ( \"MenuOpen\" ) --> false State:Increment() \u00b6 Increases the value of a stored numeric value by 1 (or a specified amount), with an optional cap parameter, which will stop incrementing above a specified number. Will throw an error is the stored value is not a number. Syntax \u00b6 State:Increment(Key: any[, Amount: Number = 1][, Cap: Number = nil]): void State:Decrement() \u00b6 Decreases the value of a stored numeric value by 1 (or a specified amount), with an optional cap parameter, which will stop decrementing below a specified number. Will throw an error if the stored value is not a number. Syntax \u00b6 State:Decrement(Key: any[, Amount: Number = 1][, Cap: Number = nil]): void Example \u00b6 local State = BasicState . new ({ Money = 100 }) local function BuyItem ( ItemName , ItemPrice ) -- A cap of 0 was specified to prevent Money from going below 0 State : Decrement ( \"Money\" , ItemPrice , 0 ) print ( string.format ( \"Bought %s for %d\" , ItemName , ItemPrice )) end BuyItem ( \"Noodles\" , 12 ) State:RawSet() \u00b6 Sets a value in the store without firing any .Changed (or :GetChangedSignal ) events. :RawSet() will also ignore the value of ProtectType , so be careful when dealing with type-sensitive data. Syntax \u00b6 State:RawSet(Key: any, Value: any): void State:Get() \u00b6 Retrieves a value stored in the state. If DefaultValue is specified, it will return that if the entry does not exist (or is equal to nil ). Syntax \u00b6 State:Get(Key: any[, DefaultValue: any = nil]): any State:GetState() \u00b6 Returns the full state object. A new table is returned, rather than a reference to the internal state object. This prevents directly overwriting the state. You should always use the :Set() method if you wish to mutate state. Syntax \u00b6 State:GetState(): Dictionary<any, any> State:GetChangedSignal() \u00b6 Returns an RBXScriptSignal which is only fired when the value of the specified key is updated. The Event fires with the following values (in order): Name Type Description NewValue any The new value of the requested entry. OldValue any The value of the entry prior to mutation. OldState Dictionary<any, any> The entire state object prior to mutation. Syntax \u00b6 State:GetChangedSignal(Key: any): RBXScriptSignal Example \u00b6 local State = BasicState . new ({ Hello = \"World\" }) State : GetChangedSignal ( \"Hello\" ): Connect ( function ( NewValue , OldValue , OldState ) print ( OldValue ) --> \"World\" print ( NewValue ) --> \"Roblox\" end ) State : Set ( \"Hello\" , \"Roblox\" ) State:Destroy() \u00b6 Clears the current state and disconnects all connections. Syntax \u00b6 State:Destroy(): void State:Roact() \u00b6 Wraps a Roact component and injects BasicState into the component's state. Experimental This feature is experimental! You may encounter bugs when using it; if so, please submit an issue . Syntax \u00b6 State:Roact(Component: Roact.Component[, Keys: any[] = nil]): Roact.Component Example \u00b6 There's a full example within the /examples directory on how to use BasicState with Roact: examples/roact-wrapped-counter . State.Changed \u00b6 An RBXScriptSignal which is fired any time the state mutates. The Event fires with the following values (in order): Warning Using :GetChangedSignal() is the preferred method for listening to state changes. Name Type Description OldState Dictionary<any, any> The entire state object prior to mutation. Key any The key of the entry which has mutated. Syntax \u00b6 State.Changed: RBXScriptSignal Example \u00b6 local State = BasicState . new ({ Hello = \"World\" }) State . Changed : Connect ( function ( OldState , Key ) print ( Key ) --> \"Hello\" print ( OldState [ Key ]) --> \"World\" print ( State : Get ( Key )) --> \"Roblox\" end ) State : Set ( \"Hello\" , \"Roblox\" ) State.ProtectType \u00b6 A boolean value which determines whether strict type-checking is enabled on the state table. This prevents changing the type of stored data, e.g. from a number to a string. This is disabled by default. To enable type-safety, simply set this property to true after initialising a new BasicState instance: State.ProtectType = true . Using :RawSet() will ignore type-checking. Syntax \u00b6 State.ProtectType: boolean Example \u00b6 local State = BasicState . new ({ Hello = \"World\" }) State . ProtectType = true State : Set ( \"Hello\" , 1234 ) --> Will throw an error: A string was expected, but it received a number. State.None \u00b6 Lua is unable to determine whether a value in a table is nil or undefined , and removes nil values from tables as a result. State.None is designed to stand in to enable you to remove keys from the state object, which was previously impossible without. It can be used directly with :Set , :SetState or :RawSet , or by using :Delete to remove a single key. Syntax \u00b6 State.None: userdata Example \u00b6 State : Delete ( \"Hello\" ) State : SetState ({ Hello = State . None , })","title":"Documentation"},{"location":"docs/#basicstatenew","text":"Creates a new state object. Accepts an optional InitialState parameter, for defining the state before it is returned.","title":"BasicState.new()"},{"location":"docs/#syntax","text":"BasicState.new([ InitialState: Dictionary<any, any> = {} ]): State","title":"Syntax"},{"location":"docs/#stateset","text":"Sets the value of a given key in the state, and then fires off any Changed signals. You should always use this when you need to change the state. Use :RawSet() to change values without invoking change events.","title":"State:Set()"},{"location":"docs/#syntax_1","text":"State:Set(Key: any, Value: any): void","title":"Syntax"},{"location":"docs/#statesetstate","text":"Set multiple values in the state. Changed signals will be fired for each modified key.","title":"State:SetState()"},{"location":"docs/#syntax_2","text":"State:SetState(StateTable: Dictionary<any, any>): void State:SetState(Callback: (State: Dictionary<any, any>) -> Dictionary<any, any>): void","title":"Syntax"},{"location":"docs/#example","text":"local State = BasicState . new ({ Location = \"Mountain\" , Greetings = { Place = \"Welcome to the Mountain!\" , Roblox = \"Hey Roblox!\" , Me = \"Hi csqrl!\" } }) State : SetState ({ Location = \"City\" , Greetings = { Place = \"Welcome to the City!\" } }) --[[ The new state object will look like this: { Location = \"City\", Greetings = { Place = \"Welcome to the City!\", Roblox = \"Hey Roblox!\", Me = \"Hi csqrl!\" } } --]]","title":"Example"},{"location":"docs/#statereset","text":"Resets state back to its initial keys/values.","title":"State:Reset()"},{"location":"docs/#syntax_3","text":"State:Reset(): void","title":"Syntax"},{"location":"docs/#statedelete","text":"Deletes a key from the store by setting its value to State.None (internally converted to nil ).","title":"State:Delete()"},{"location":"docs/#syntax_4","text":"State:Delete(Key: any): void","title":"Syntax"},{"location":"docs/#example_1","text":"local State = BasicState . new ({ Hello = \"World\" }) State : Delete ( \"Hello\" ) print ( State : Get ( \"Hello\" )) --> nil","title":"Example"},{"location":"docs/#statetoggle","text":"Toggles a stored Boolean value between true and false . Will throw an error if the stored value is not a Boolean.","title":"State:Toggle()"},{"location":"docs/#syntax_5","text":"State:Toggle(Key: any): void","title":"Syntax"},{"location":"docs/#example_2","text":"local State = BasicState . new ({ MenuOpen = false }) State : Toggle ( \"MenuOpen\" ) --> true State : Toggle ( \"MenuOpen\" ) --> false","title":"Example"},{"location":"docs/#stateincrement","text":"Increases the value of a stored numeric value by 1 (or a specified amount), with an optional cap parameter, which will stop incrementing above a specified number. Will throw an error is the stored value is not a number.","title":"State:Increment()"},{"location":"docs/#syntax_6","text":"State:Increment(Key: any[, Amount: Number = 1][, Cap: Number = nil]): void","title":"Syntax"},{"location":"docs/#statedecrement","text":"Decreases the value of a stored numeric value by 1 (or a specified amount), with an optional cap parameter, which will stop decrementing below a specified number. Will throw an error if the stored value is not a number.","title":"State:Decrement()"},{"location":"docs/#syntax_7","text":"State:Decrement(Key: any[, Amount: Number = 1][, Cap: Number = nil]): void","title":"Syntax"},{"location":"docs/#example_3","text":"local State = BasicState . new ({ Money = 100 }) local function BuyItem ( ItemName , ItemPrice ) -- A cap of 0 was specified to prevent Money from going below 0 State : Decrement ( \"Money\" , ItemPrice , 0 ) print ( string.format ( \"Bought %s for %d\" , ItemName , ItemPrice )) end BuyItem ( \"Noodles\" , 12 )","title":"Example"},{"location":"docs/#staterawset","text":"Sets a value in the store without firing any .Changed (or :GetChangedSignal ) events. :RawSet() will also ignore the value of ProtectType , so be careful when dealing with type-sensitive data.","title":"State:RawSet()"},{"location":"docs/#syntax_8","text":"State:RawSet(Key: any, Value: any): void","title":"Syntax"},{"location":"docs/#stateget","text":"Retrieves a value stored in the state. If DefaultValue is specified, it will return that if the entry does not exist (or is equal to nil ).","title":"State:Get()"},{"location":"docs/#syntax_9","text":"State:Get(Key: any[, DefaultValue: any = nil]): any","title":"Syntax"},{"location":"docs/#stategetstate","text":"Returns the full state object. A new table is returned, rather than a reference to the internal state object. This prevents directly overwriting the state. You should always use the :Set() method if you wish to mutate state.","title":"State:GetState()"},{"location":"docs/#syntax_10","text":"State:GetState(): Dictionary<any, any>","title":"Syntax"},{"location":"docs/#stategetchangedsignal","text":"Returns an RBXScriptSignal which is only fired when the value of the specified key is updated. The Event fires with the following values (in order): Name Type Description NewValue any The new value of the requested entry. OldValue any The value of the entry prior to mutation. OldState Dictionary<any, any> The entire state object prior to mutation.","title":"State:GetChangedSignal()"},{"location":"docs/#syntax_11","text":"State:GetChangedSignal(Key: any): RBXScriptSignal","title":"Syntax"},{"location":"docs/#example_4","text":"local State = BasicState . new ({ Hello = \"World\" }) State : GetChangedSignal ( \"Hello\" ): Connect ( function ( NewValue , OldValue , OldState ) print ( OldValue ) --> \"World\" print ( NewValue ) --> \"Roblox\" end ) State : Set ( \"Hello\" , \"Roblox\" )","title":"Example"},{"location":"docs/#statedestroy","text":"Clears the current state and disconnects all connections.","title":"State:Destroy()"},{"location":"docs/#syntax_12","text":"State:Destroy(): void","title":"Syntax"},{"location":"docs/#stateroact","text":"Wraps a Roact component and injects BasicState into the component's state. Experimental This feature is experimental! You may encounter bugs when using it; if so, please submit an issue .","title":"State:Roact()"},{"location":"docs/#syntax_13","text":"State:Roact(Component: Roact.Component[, Keys: any[] = nil]): Roact.Component","title":"Syntax"},{"location":"docs/#example_5","text":"There's a full example within the /examples directory on how to use BasicState with Roact: examples/roact-wrapped-counter .","title":"Example"},{"location":"docs/#statechanged","text":"An RBXScriptSignal which is fired any time the state mutates. The Event fires with the following values (in order): Warning Using :GetChangedSignal() is the preferred method for listening to state changes. Name Type Description OldState Dictionary<any, any> The entire state object prior to mutation. Key any The key of the entry which has mutated.","title":"State.Changed"},{"location":"docs/#syntax_14","text":"State.Changed: RBXScriptSignal","title":"Syntax"},{"location":"docs/#example_6","text":"local State = BasicState . new ({ Hello = \"World\" }) State . Changed : Connect ( function ( OldState , Key ) print ( Key ) --> \"Hello\" print ( OldState [ Key ]) --> \"World\" print ( State : Get ( Key )) --> \"Roblox\" end ) State : Set ( \"Hello\" , \"Roblox\" )","title":"Example"},{"location":"docs/#stateprotecttype","text":"A boolean value which determines whether strict type-checking is enabled on the state table. This prevents changing the type of stored data, e.g. from a number to a string. This is disabled by default. To enable type-safety, simply set this property to true after initialising a new BasicState instance: State.ProtectType = true . Using :RawSet() will ignore type-checking.","title":"State.ProtectType"},{"location":"docs/#syntax_15","text":"State.ProtectType: boolean","title":"Syntax"},{"location":"docs/#example_7","text":"local State = BasicState . new ({ Hello = \"World\" }) State . ProtectType = true State : Set ( \"Hello\" , 1234 ) --> Will throw an error: A string was expected, but it received a number.","title":"Example"},{"location":"docs/#statenone","text":"Lua is unable to determine whether a value in a table is nil or undefined , and removes nil values from tables as a result. State.None is designed to stand in to enable you to remove keys from the state object, which was previously impossible without. It can be used directly with :Set , :SetState or :RawSet , or by using :Delete to remove a single key.","title":"State.None"},{"location":"docs/#syntax_16","text":"State.None: userdata","title":"Syntax"},{"location":"docs/#example_8","text":"State : Delete ( \"Hello\" ) State : SetState ({ Hello = State . None , })","title":"Example"},{"location":"example/","text":"Tab Highlighting \u00b6 This is a direct extract from the avatar editor UI controller in ~~Bloxikins World~~. BasicState is being used to control which tab is currently in focus and which asset category to display to players. -- Reference the tab buttons UI container local Tabs = script . Parent . TabButtons -- Create a new BasicState object with the category preset to \"HAT\" local State = BasicState . new ({ Category = \"HAT\" }) -- Update the tabs when the \"Category\" property changes State : GetChangedSignal ( \"Category\" ): Connect ( function ( NewCategory ) -- Iterate through each tab button in the container for _ , TabButton in next , Tabs : GetChildren () do -- Ignore any UI elements which are not ImageButtons if not TabButton : IsA ( \"ImageButton\" ) then continue end -- If the TabButton's Name matches the new value of Category, then it should -- be selected local Selected = TabButton . Name == NewCategory -- If Selected == true, set the button to yellow; otherwise make it white TabButton . ImageColor3 = Selected and Color3 . fromRGB ( 255 , 170 , 0 ) or Color3 . fromRGB ( 235 , 235 , 235 ) end --[[ This function has been truncated for the sake of this example. The full source code for this method also updates the displayed assets in the avatar editor UI. --]] end ) -- Iterate through the children of the TabButton container for _ , TabButton in next , Tabs : GetChildren () do -- Ignore Instances which are not ImageButtons if not TabButton : IsA ( \"ImageButton\" ) then continue end -- If the TabButton's Name is not uppercase, then ignore it if TabButton . Name ~= TabButton . Name : upper () then continue end -- Listen for taps and clicks on the TabButton TabButton . MouseButton1Click : Connect ( function () -- Set Category to the name of TabButton on click State : Set ( \"Category\" , TabButton . Name ) end ) end","title":"Examples"},{"location":"example/#tab-highlighting","text":"This is a direct extract from the avatar editor UI controller in ~~Bloxikins World~~. BasicState is being used to control which tab is currently in focus and which asset category to display to players. -- Reference the tab buttons UI container local Tabs = script . Parent . TabButtons -- Create a new BasicState object with the category preset to \"HAT\" local State = BasicState . new ({ Category = \"HAT\" }) -- Update the tabs when the \"Category\" property changes State : GetChangedSignal ( \"Category\" ): Connect ( function ( NewCategory ) -- Iterate through each tab button in the container for _ , TabButton in next , Tabs : GetChildren () do -- Ignore any UI elements which are not ImageButtons if not TabButton : IsA ( \"ImageButton\" ) then continue end -- If the TabButton's Name matches the new value of Category, then it should -- be selected local Selected = TabButton . Name == NewCategory -- If Selected == true, set the button to yellow; otherwise make it white TabButton . ImageColor3 = Selected and Color3 . fromRGB ( 255 , 170 , 0 ) or Color3 . fromRGB ( 235 , 235 , 235 ) end --[[ This function has been truncated for the sake of this example. The full source code for this method also updates the displayed assets in the avatar editor UI. --]] end ) -- Iterate through the children of the TabButton container for _ , TabButton in next , Tabs : GetChildren () do -- Ignore Instances which are not ImageButtons if not TabButton : IsA ( \"ImageButton\" ) then continue end -- If the TabButton's Name is not uppercase, then ignore it if TabButton . Name ~= TabButton . Name : upper () then continue end -- Listen for taps and clicks on the TabButton TabButton . MouseButton1Click : Connect ( function () -- Set Category to the name of TabButton on click State : Set ( \"Category\" , TabButton . Name ) end ) end","title":"Tab Highlighting"}]}